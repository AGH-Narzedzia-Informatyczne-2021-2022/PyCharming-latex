\subsection{Application core}
\label{ssec:appcore}

Our application is based on python library called \underline{\textit{discord.py}}. It helps us listen to guilds'\footnote{also known as \textit{discord servers}.} events such as messages and reactions, but does not provide proper way to define commands, which is why we needed to build our own command handling system.

\subsubsection{Event catching}
\label{sssec:eventcatching}

In order to listen to messages, this basic code needs to be implemented:

\begin{minted}[fontsize=\footnotesize]{python}
import discord
from Config import dev_config as dev
from logger import log

def main():
    client = discord.Client()
    
    @client.event
    async def on_ready():
        log(f'{client.user} has sucessfully connected to Discord!')
    
    @client.event
    async def on_message(ctx):
        if ctx.author == client.user:
            return
        log(f'{ctx.author.name} has sent a message: {ctx.content}')
    
    client.run(dev.TOKEN)

if __name__ == '__main__':
    main()
\end{minted}

It connects to guilds and starts listening for events. When message is sent, the \textit{on\_message} function is executed, with all message information stored in \textit{ctx} variable. Also, here is some math I don't understand:

$$\lim_{n \to \infty} \sqrt[n]{n} = 1$$

\newpage
\subsubsection{Development config file}
\label{sssec:devfile}

\textit{dev\_config} file contains information about token used to connect to Discord, developer credentials, database connection and other information that should not be put in public repository. It is also used to differentiate developers in the process of application testing. For example, let three other people work on the project at the same time, running three instances of bot in parallel. Then let only one of them use \textbf{!whatis whatis} command. This is what will happen:

\begin{figure}[h]
    \centering
    \includegraphics{Pictures/whatis.png}
    \caption{This is what happens with more than one app instance running.}
    \label{fig:overreact}
\end{figure}

\noindent
To fix this, let's change the code a bit:

\begin{minted}[fontsize=\footnotesize]{python}
#Contents of dev_config:
DEVMODE = True
CHANNEL = 'test'

...
@client.event
async def on_message(ctx):

    #Do not continue if bot is the autor of the message
    if ctx.author == client.user:
        return

    #While in development mode, continue only if using proper channel
    if dev.DEVMODE:
        if ctx.channel.name != dev.CHANNEL:
            return
...
\end{minted}

\noindent
If the constant \textit{DEVMODE} is set to \textit{True}, bot will check if the command has been invoked from \textit{test} channel. With each developer having his own channel to test his features, it solves the problem of bot overreacting to commands (see Figure~\ref{fig:overreact}.).

\subsection{Categories and commands}
\label{ssec:categories_commands}

\subsubsection{Categories}
\label{sssec:cat}

Some categories we will have:

\input{./Tables/categories_tab.tex}

\subsubsection{Commands}
\label{sssec:commands}

We have a few ideas for commands:

\begin{enumerate}

\item In admin category:
    \begin{itemize}
         \item[-] ban
         \item[-] kick
         \item[-] mute
         \item[-] unmute
    \end{itemize}
    
\item In utility category:
    \begin{itemize}
         \item[-] list
         \item[-] man
         \item[-] whatis
    \end{itemize}

\end{enumerate}

For more category info, see Table~\ref{tab:categories}.